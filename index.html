<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Volumetric 3D Interactive Website</title>
    <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@300;400;500;600&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Montserrat', 'Segoe UI', sans-serif;
        }
        body {
            overflow: hidden;
            background: #000;
            touch-action: none;
        }
        canvas {
            display: block;
            position: fixed;
            top: 0;
            left: 0;
        }
        #loading {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-family: 'Montserrat', sans-serif;
            font-size: 1.5rem;
            text-align: center;
            z-index: 1000;
        }
        #ui-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 10;
        }
        .nav-item {
            position: absolute;
            color: rgba(255,255,255,0.7);
            font-size: 1rem;
            text-transform: uppercase;
            letter-spacing: 3px;
            cursor: pointer;
            pointer-events: auto;
            transition: all 0.3s ease;
            text-shadow: 0 0 10px rgba(255,255,255,0.5);
        }
        .nav-item:hover {
            color: white;
            text-shadow: 0 0 15px rgba(255,255,255,0.8);
        }
        #podcast-nav { bottom: 20px; left: 20px; }
        #store-nav { bottom: 20px; right: 20px; }
        #blog-nav { top: 20px; left: 20px; }
        #glass-nav { top: 20px; right: 20px; }
    </style>
</head>
<body>
    <div id="loading">Initializing 3D Experience...</div>
    <div id="ui-container">
        <div class="nav-item" id="podcast-nav">PODCAST</div>
        <div class="nav-item" id="store-nav">STORE</div>
        <div class="nav-item" id="blog-nav">BLOG</div>
        <div class="nav-item" id="glass-nav">GLASS</div>
    </div>
    
    !-- ▼▼▼ ADD THESE SCRIPTS HERE ▼▼▼ (right before your main script) -->
    <!-- Load Three.js first -->
    <script src="lib/three.min.js"></script>
    <!-- Then Cannon.js -->
    <script src="lib/cannon.min.js"></script>
    <!-- Then post-processing files -->
    <script src="lib/postprocessing/EffectComposer.js"></script>
    <script src="lib/postprocessing/RenderPass.js"></script>
    <script src="lib/postprocessing/ShaderPass.js"></script>

    <!-- Three.js Library from Local Files -->
    <script src="lib/three.module.js"></script>
    <script src="lib/postprocessing/EffectComposer.js"></script>
    <script src="lib/postprocessing/RenderPass.js"></script>
    <script src="lib/postprocessing/ShaderPass.js"></script>

    <script>
        // MAIN APPLICATION
        class VolumetricWebsite {
            constructor() {
                this.initScene();
                this.initPhysics();
                this.loadAssets().then(() => {
                    this.createWebsiteModel();
                    this.setupControls();
                    this.createPostProcessing();
                    this.hideLoading();
                    this.animate();
                });
            }

            initScene() {
                // Scene
                this.scene = new THREE.Scene();
                this.scene.background = null;

                // Camera
                this.camera = new THREE.PerspectiveCamera(
                    60, 
                    window.innerWidth / window.innerHeight, 
                    0.1, 
                    1000
                );
                this.camera.position.z = 15;

                // Renderer
                this.renderer = new THREE.WebGLRenderer({ 
                    antialias: true, 
                    alpha: true,
                    powerPreference: "high-performance"
                });
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
                document.body.appendChild(this.renderer.domElement);

                // Lights (minimal - most lighting comes from materials)
                const ambient = new THREE.AmbientLight(0x404040, 0.5);
                this.scene.add(ambient);

                const directional = new THREE.DirectionalLight(0xffffff, 0.3);
                directional.position.set(1, 1, 1);
                this.scene.add(directional);
            }

            initPhysics() {
                // Physics world
                this.world = new CANNON.World();
                this.world.gravity.set(0, 0, 0);
                this.world.broadphase = new CANNON.NaiveBroadphase();
                this.world.solver.iterations = 10;

                // Materials
                this.websiteMaterial = new CANNON.Material("website");
                this.defaultMaterial = new CANNON.Material("default");
                
                const contactMaterial = new CANNON.ContactMaterial(
                    this.websiteMaterial,
                    this.defaultMaterial,
                    { friction: 0.1, restitution: 0.3 }
                );
                this.world.addContactMaterial(contactMaterial);
            }

            async loadAssets() {
                // Load fonts and textures
                this.font = await new Promise(resolve => {
                    new THREE.FontLoader().load(
                        'https://cdn.jsdelivr.net/npm/three@0.132.2/examples/fonts/helvetiker_regular.typeface.json', 
                        resolve
                    );
                });

                // Create video texture
                this.video = document.createElement('video');
                this.video.loop = true;
                this.video.muted = true;
                this.video.playsInline = true;
                this.video.src = 'assets/video/background.mp4';
                
                await new Promise(resolve => {
                    this.video.oncanplay = resolve;
                    this.video.play().catch(e => console.log("Video play error:", e));
                });

                this.videoTexture = new THREE.VideoTexture(this.video);
                this.videoTexture.minFilter = THREE.LinearFilter;
                this.videoTexture.magFilter = THREE.LinearFilter;
            }

            createWebsiteModel() {
                // Main website model group
                this.websiteModel = new THREE.Group();
                this.scene.add(this.websiteModel);

                // Create volumetric body with video texture
                this.createMainBody();
                
                // Create UI elements with depth
                this.createUIElements();
                
                // Create physics body
                this.createPhysicsBody();
            }

            createMainBody() {
                // Main body geometry - thick with depth
                const bodyGeometry = new THREE.BoxGeometry(8, 10, 2, 32, 32, 4);
                
                // Material with video texture and self-illumination
                const bodyMaterial = new THREE.MeshPhysicalMaterial({
                    map: this.videoTexture,
                    emissive: 0x444444,
                    emissiveIntensity: 0.5,
                    transmission: 0.2,
                    thickness: 1.5,
                    roughness: 0.3,
                    metalness: 0.1,
                    side: THREE.DoubleSide
                });

                this.mainBody = new THREE.Mesh(bodyGeometry, bodyMaterial);
                this.mainBody.castShadow = true;
                this.mainBody.receiveShadow = true;
                this.websiteModel.add(this.mainBody);

                // Add edge highlights
                const edges = new THREE.EdgesGeometry(bodyGeometry, 20);
                const edgeMaterial = new THREE.LineBasicMaterial({ 
                    color: 0x88ffff,
                    transparent: true,
                    opacity: 0.7,
                    linewidth: 2
                });
                const wireframe = new THREE.LineSegments(edges, edgeMaterial);
                this.mainBody.add(wireframe);
            }

            createUIElements() {
                // Create extruded text elements
                this.createTextElement("PODCAST", [-3, 3, 1.01], 0.15, 0x5eeaff);
                this.createTextElement("STORE", [3, 3, 1.01], 0.15, 0xff5e5e);
                this.createTextElement("BLOG", [-3, -3, 1.01], 0.15, 0x9d5eff);
                this.createTextElement("GLASS", [3, -3, 1.01], 0.15, 0x5eff87);

                // Create interactive panels
                this.createPanelElement([0, 0, 1.01], [5, 5, 0.1], 0xffffff);
            }

            createTextElement(text, position, depth, color) {
                const geometry = new THREE.TextGeometry(text, {
                    font: this.font,
                    size: 0.5,
                    height: depth,
                    curveSegments: 8,
                    bevelEnabled: true,
                    bevelThickness: 0.02,
                    bevelSize: 0.01
                });
                
                const material = new THREE.MeshPhysicalMaterial({
                    color: color,
                    emissive: color,
                    emissiveIntensity: 0.7,
                    transmission: 0.9,
                    roughness: 0.1,
                    thickness: 0.3,
                    side: THREE.DoubleSide
                });
                
                const mesh = new THREE.Mesh(geometry, material);
                mesh.position.set(position[0], position[1], position[2]);
                this.websiteModel.add(mesh);
            }

            createPanelElement(position, size, color) {
                const geometry = new THREE.BoxGeometry(...size);
                const material = new THREE.MeshPhysicalMaterial({
                    color: color,
                    emissive: color,
                    emissiveIntensity: 0.3,
                    transmission: 0.8,
                    roughness: 0.2,
                    thickness: 0.5,
                    side: THREE.DoubleSide,
                    transparent: true,
                    opacity: 0.2
                });
                
                const panel = new THREE.Mesh(geometry, material);
                panel.position.set(position[0], position[1], position[2]);
                this.websiteModel.add(panel);
                return panel;
            }

            createPhysicsBody() {
                // Create compound physics shape
                const halfExtents = new CANNON.Vec3(4, 5, 1);
                const boxShape = new CANNON.Box(halfExtents);
                
                this.websiteBody = new CANNON.Body({
                    mass: 3,
                    shape: boxShape,
                    material: this.websiteMaterial,
                    linearDamping: 0.05,
                    angularDamping: 0.2
                });
                
                this.world.addBody(this.websiteBody);
            }

            createPostProcessing() {
                // Create effect composer
                this.composer = new THREE.EffectComposer(this.renderer);
                
                // Add render pass
                const renderPass = new THREE.RenderPass(this.scene, this.camera);
                this.composer.addPass(renderPass);
                
                // Add custom shader pass for lighting effects
                this.lightingPass = new THREE.ShaderPass({
                    uniforms: {
                        tDiffuse: { value: null },
                        time: { value: 0 },
                        resolution: { value: new THREE.Vector2(window.innerWidth, window.innerHeight) }
                    },
                    vertexShader: `
                        varying vec2 vUv;
                        void main() {
                            vUv = uv;
                            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                        }
                    `,
                    fragmentShader: `
                        uniform sampler2D tDiffuse;
                        uniform float time;
                        uniform vec2 resolution;
                        varying vec2 vUv;

                        void main() {
                            vec4 color = texture2D(tDiffuse, vUv);
                            
                            // Add pulsing glow effect
                            float pulse = 0.5 + 0.5 * sin(time * 2.0);
                            vec3 glow = vec3(0.3, 0.4, 0.8) * pulse * 0.1;
                            
                            // Edge detection
                            vec2 texelSize = 1.0 / resolution;
                            float edge = 0.0;
                            edge += abs(texture2D(tDiffuse, vUv + texelSize * vec2(1,0)).r - color.r);
                            edge += abs(texture2D(tDiffuse, vUv + texelSize * vec2(0,1)).r - color.r);
                            edge = clamp(edge * 2.0, 0.0, 1.0);
                            
                            gl_FragColor = vec4(color.rgb + glow + edge * 0.3, color.a);
                        }
                    `
                });
                this.composer.addPass(this.lightingPass);
            }

            setupControls() {
                // Mouse/touch drag controls
                this.isDragging = false;
                this.previousPosition = { x: 0, y: 0 };
                
                // Mouse events
                this.renderer.domElement.addEventListener('mousedown', (e) => {
                    this.isDragging = true;
                    this.previousPosition = { x: e.clientX, y: e.clientY };
                    document.body.style.cursor = 'grabbing';
                });
                
                document.addEventListener('mouseup', () => {
                    this.isDragging = false;
                    document.body.style.cursor = 'grab';
                });
                
                document.addEventListener('mousemove', (e) => {
                    if (!this.isDragging) return;
                    
                    const deltaX = e.clientX - this.previousPosition.x;
                    const deltaY = e.clientY - this.previousPosition.y;
                    
                    // Apply rotational force
                    const force = new CANNON.Vec3(
                        deltaY * 0.001,
                        -deltaX * 0.001,
                        (Math.abs(deltaX) - Math.abs(deltaY)) * 0.0005
                    );
                    
                    this.websiteBody.applyImpulse(
                        force, 
                        new CANNON.Vec3(0, 0, 0.5)
                    );
                    
                    this.previousPosition = { x: e.clientX, y: e.clientY };
                });
                
                // Touch events
                this.renderer.domElement.addEventListener('touchstart', (e) => {
                    this.isDragging = true;
                    this.previousPosition = { 
                        x: e.touches[0].clientX, 
                        y: e.touches[0].clientY 
                    };
                }, { passive: true });
                
                document.addEventListener('touchend', () => {
                    this.isDragging = false;
                });
                
                document.addEventListener('touchmove', (e) => {
                    if (!this.isDragging || !e.touches[0]) return;
                    
                    const deltaX = e.touches[0].clientX - this.previousPosition.x;
                    const deltaY = e.touches[0].clientY - this.previousPosition.y;
                    
                    // Apply stronger force for touch
                    const force = new CANNON.Vec3(
                        deltaY * 0.002,
                        -deltaX * 0.002,
                        (Math.abs(deltaX) - Math.abs(deltaY)) * 0.001
                    );
                    
                    this.websiteBody.applyImpulse(
                        force, 
                        new CANNON.Vec3(0, 0, 0.5)
                    );
                    
                    this.previousPosition = { 
                        x: e.touches[0].clientX, 
                        y: e.touches[0].clientY 
                    };
                }, { passive: true });
                
                // Gyroscope controls for mobile
                if (window.DeviceOrientationEvent) {
                    window.addEventListener('deviceorientation', (e) => {
                        if (!e.alpha) return;
                        
                        // Convert device orientation to quaternion
                        const alpha = THREE.MathUtils.degToRad(e.alpha || 0);
                        const beta = THREE.MathUtils.degToRad(e.beta || 0);
                        const gamma = THREE.MathUtils.degToRad(e.gamma || 0);
                        
                        const quaternion = new CANNON.Quaternion();
                        quaternion.setFromEuler(-beta, alpha, -gamma, 'YXZ');
                        
                        // Smooth transition
                        this.websiteBody.quaternion.slerp(
                            quaternion,
                            0.3,
                            this.websiteBody.quaternion
                        );
                    });
                }
                
                // UI event listeners
                document.getElementById('podcast-nav').addEventListener('click', () => {
                    this.applyRotationForce(0, Math.PI/2, 0);
                });
                
                document.getElementById('store-nav').addEventListener('click', () => {
                    this.applyRotationForce(0, -Math.PI/2, 0);
                });
                
                document.getElementById('blog-nav').addEventListener('click', () => {
                    this.applyRotationForce(Math.PI/2, 0, 0);
                });
                
                document.getElementById('glass-nav').addEventListener('click', () => {
                    this.applyRotationForce(-Math.PI/2, 0, 0);
                });
                
                // Window resize
                window.addEventListener('resize', () => {
                    this.camera.aspect = window.innerWidth / window.innerHeight;
                    this.camera.updateProjectionMatrix();
                    this.renderer.setSize(window.innerWidth, window.innerHeight);
                    this.composer.setSize(window.innerWidth, window.innerHeight);
                    this.lightingPass.uniforms.resolution.value.set(
                        window.innerWidth, 
                        window.innerHeight
                    );
                });
            }

            applyRotationForce(x, y, z) {
                const targetQuat = new CANNON.Quaternion();
                targetQuat.setFromEuler(x, y, z);
                
                // Calculate shortest rotation
                const currentQuat = this.websiteBody.quaternion.clone();
                const deltaQuat = targetQuat.clone();
                deltaQuat.inverse();
                deltaQuat.mult(currentQuat, deltaQuat);
                
                // Convert to axis-angle
                const angle = 2 * Math.acos(deltaQuat.w);
                const axis = new CANNON.Vec3();
                if (angle > 0.001) {
                    const s = Math.sqrt(1 - deltaQuat.w * deltaQuat.w);
                    axis.set(deltaQuat.x / s, deltaQuat.y / s, deltaQuat.z / s);
                }
                
                // Apply torque
                this.websiteBody.angularVelocity.setZero();
                this.websiteBody.applyImpulse(
                    axis.scale(angle * 0.1),
                    new CANNON.Vec3()
                );
            }

            hideLoading() {
                document.getElementById('loading').style.opacity = '0';
                setTimeout(() => {
                    document.getElementById('loading').style.display = 'none';
                }, 500);
            }

            animate() {
                requestAnimationFrame(() => this.animate());
                
                // Update physics
                this.world.step(1/60);
                
                // Sync 3D model with physics
                this.websiteModel.position.copy(this.websiteBody.position);
                this.websiteModel.quaternion.copy(this.websiteBody.quaternion);
                
                // Update post-processing
                this.lightingPass.uniforms.time.value += 0.01;
                
                // Render with effects
                this.composer.render();
            }
        }

        // Start the application when all is ready
        document.addEventListener('DOMContentLoaded', () => {
            new VolumetricWebsite();
        });
    </script>
</body>
</html>
