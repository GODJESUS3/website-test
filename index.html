<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Advanced 3D Website</title>
<style>
body {
margin: 0;
overflow: hidden;
background: #000;
touch-action: none;
}
canvas {
display: block;
}
#ui {
position: absolute;
top: 20px;
left: 20px;
color: white;
font-family: sans-serif;
font-size: 1.2em;
}
.nav-item {
cursor: pointer;
margin-right: 15px;
opacity: 0.8;
transition: opacity 0.2s;
}
.nav-item:hover, .nav-item.active {
opacity: 1;
}
</style>
</head>
<body>
<div id="ui">
<span class="nav-item active" data-section="podcast">PODCAST</span>
<span class="nav-item" data-section="store">STORE</span>
<span class="nav-item" data-section="blog">BLOG</span>
<span class="nav-item" data-section="glass">GLASS</span>
</div>
Generated code
<script type="module">
    import * as THREE from './lib/three.module.js';
    import * as CANNON from './lib/cannon-es.js';

    class Interactive3DWebsite {
        constructor() {
            this.initThree();
            this.initCannon();
            this.createWebsiteModel();
            this.setupInteractions();
            this.setupUI();
            this.animate();
        }

        initThree() {
            // Scene
            this.scene = new THREE.Scene();
            this.scene.background = new THREE.Color(0x000000);
            this.clock = new THREE.Clock();

            // Camera
            this.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 100);
            this.camera.position.z = 10;

            // Renderer
            this.renderer = new THREE.WebGLRenderer({ 
                antialias: true 
            });
            this.renderer.setSize(window.innerWidth, window.innerHeight);
            this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            document.body.appendChild(this.renderer.domElement);
        }

        initCannon() {
            // World
            this.world = new CANNON.World();
            this.world.gravity.set(0, 0, 0); // No gravity
            this.world.broadphase = new CANNON.NaiveBroadphase();
            this.world.solver.iterations = 10;

            // Materials
            this.physicsMaterials = {
                website: new CANNON.Material('websiteMaterial'),
                default: new CANNON.Material('defaultMaterial')
            };
            const contactMaterial = new CANNON.ContactMaterial(
                this.physicsMaterials.website, 
                this.physicsMaterials.default, 
                { friction: 0.4, restitution: 0.7 }
            );
            this.world.addContactMaterial(contactMaterial);
        }

        createWebsiteModel() {
            // Main group
            this.websiteModel = new THREE.Group();
            this.scene.add(this.websiteModel);

            // Volumetric body (as base)
            this.createMainBody();

            // Section content maps
            this.sectionContentMaps = {
                podcast: this.createContentMap('Podcast Content'),
                store: this.createContentMap('Store Content'),
                blog: this.createContentMap('Blog Content'),
                glass: this.createContentMap('Glass Content')
            };

            // Visible face display
            this.sectionDisplayMaterial = new THREE.MeshPhysicalMaterial({
                map: this.sectionContentMaps.podcast, // Initial content
                side: THREE.DoubleSide,
                transmission: 0.2, // See-through effect
                roughness: 0.2,
                metalness: 0.1,
                clearcoat: 1,
                clearcoatRoughness: 0.1,
                thickness: 1.0
            });
            this.createDisplayFace(this.sectionDisplayMaterial);

            // Add physics to entire model
            this.createPhysicsBody();
        }

        createMainBody() {
            // Create 3D shape (base of website)
            const bodyGeometry = new THREE.BoxGeometry(8, 10, 1.5, 32, 32, 4);
            this.bodyMaterial = new THREE.MeshPhysicalMaterial({
                color: 0x111122,
                emissive: 0x222244,
                emissiveIntensity: 0.7,
                transmission: 0.2, // See-through
                roughness: 0.25,
                metalness: 0.05,
                clearcoat: 0.5,
                clearcoatRoughness: 0.1,
                side: THREE.DoubleSide
            });

            this.mainBody = new THREE.Mesh(bodyGeometry, this.bodyMaterial);
            this.websiteModel.add(this.mainBody);

            // Add edge wireframe highlight
            const edges = new THREE.EdgesGeometry(bodyGeometry, 15);
            const wireframeMaterial = new THREE.LineBasicMaterial({ 
                color: 0x88ffff, 
                transparent: true, 
                opacity: 0.6, 
                linewidth: 2 
            });
            const wireframe = new THREE.LineSegments(edges, wireframeMaterial);
            this.mainBody.add(wireframe);

        }

        createDisplayFace(material) {
            // Create 2D surface to display active content on
            const faceGeometry = new THREE.PlaneGeometry(7, 9);
            this.displayFace = new THREE.Mesh(faceGeometry, material);
            this.displayFace.position.z = 0.76; // Just in front
            this.websiteModel.add(this.displayFace);
        }

        createContentMap(text) {
            // Create dynamic texture for each "section" (podcast, store, etc.)
            const canvas = document.createElement('canvas');
            canvas.width = 512;
            canvas.height = 512;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = '#333'; // Black backdrop
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.font = '60px sans-serif';
            ctx.fillStyle = 'white';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(text, canvas.width / 2, canvas.height / 2); // Label section
            return new THREE.CanvasTexture(canvas);
        }

        setActiveSection(section) {
            // Change active face display
            if (this.activeSection === section) return; // Nothing to do
            this.activeSection = section;

            // Transition new map
            const map = this.sectionContentMaps[section];
            gsap.to(this.sectionDisplayMaterial, {
                map: map, // Change content
                duration: 0.4 // Cross-fade effect
            });
        }

        createPhysicsBody() {
             // Physical representation
             const halfExtents = new CANNON.Vec3(4, 5, 0.75);
             this.websiteBody = new CANNON.Body({
                mass: 2,
                shape: new CANNON.Box(halfExtents),
                material: this.physicsMaterials.website,
                linearDamping: 0.1,
                angularDamping: 0.3
            });

             this.world.addBody(this.websiteBody);

        }

        setupInteractions() {
            // Track drag state
            this.isDragging = false;
            this.previousPosition = new THREE.Vector2();

             // Events
             this.renderer.domElement.addEventListener('mousedown', (e) => this.onDragStart(e));
             this.renderer.domElement.addEventListener('touchstart', (e) => this.onDragStart(e));
             document.addEventListener('mouseup', () => this.onDragEnd());
             document.addEventListener('touchend', () => this.onDragEnd());
             document.addEventListener('mousemove', (e) => this.onDragMove(e));
             document.addEventListener('touchmove', (e) => this.onDragMove(e));
             
             // Gyro Controls (mobile)
             if (window.DeviceOrientationEvent) {
                window.addEventListener('deviceorientation', (e) => {
                    if (e.alpha == null) return;

                     // Use euler angles to avoid quaternion locks
                     const euler = new THREE.Euler(
                        THREE.MathUtils.degToRad(e.beta - 90), // X rotation 
                        THREE.MathUtils.degToRad(e.alpha), // Y rotation (full 360)
                        THREE.MathUtils.degToRad(-e.gamma), // Z (roll)
                        'YXZ'
                    );

                     const quat = new THREE.Quaternion().setFromEuler(euler);
                     this.websiteBody.quaternion.copy(quat); // Immediate copy
                 });
             }
        }

        setupUI() {
            // UI Click Handlers
            document.querySelectorAll('#ui .nav-item').forEach(item => {
                item.addEventListener('click', () => {
                     // New page load (change UI)
                    this.setActiveSection(item.dataset.section);
                    document.querySelectorAll('.nav-item').forEach(nav => nav.classList.remove('active'));
                    item.classList.add('active');
                });
            });
        }

        onDragStart(e) {
            // Store starting position
            this.isDragging = true;
            this.startDragPosition = this.getMousePosition(e);

        }

        onDragEnd() {
            // Release control
            this.isDragging = false;

        }

        onDragMove(e) {
            // Apply force (touch or mouse)
            if (!this.isDragging) return;

            const currentPosition = this.getMousePosition(e);
            const deltaX = currentPosition.x - this.startDragPosition.x;
            const deltaY = currentPosition.y - this.startDragPosition.y;

             // Base strength on touch vs mouse
             const touchMultiplier = (e.touches) ? 2 : 1;
             const forceVector = new CANNON.Vec3(
                deltaY * 0.001 * touchMultiplier, 
                -deltaX * 0.001 * touchMultiplier, 
                0
             ); // XY torque

            this.websiteBody.applyImpulse(forceVector, new CANNON.Vec3(0, 0, 0.5));
            this.startDragPosition.copy(currentPosition); // Update reference

        }

        getMousePosition(event) {
            // Get world pos based on pixel coords
            const x = (event.clientX / window.innerWidth) * 2 - 1;
            const y = -(event.clientY / window.innerHeight) * 2 + 1;
            return new THREE.Vector2(x, y);

        }

        animate() {
            // Main render loop
            requestAnimationFrame(() => this.animate());
            const delta = this.clock.getDelta();

            // Apply simple gravity constraint (to ground)
            this.bodyPositionConstraint();

            // Cannon step world
            this.world.step(1/60, delta);

            // Physics positions to Three
            this.websiteModel.position.copy(this.websiteBody.position);
            this.websiteModel.quaternion.copy(this.websiteBody.quaternion);

            this.renderer.render(this.scene, this.camera);

        }

        bodyPositionConstraint() {
            // Minor spring back to center & upright

             const forceScale = 0.05;
             const maxLinearVelocity = 5;
             const maxAngularVelocity = 2;

             // Center pull
             const positionError = new CANNON.Vec3().copy(this.websiteBody.position).scale(-forceScale);
             this.websiteBody.applyForce(positionError, new CANNON.Vec3(0, 0, 0)); // Apply center pull

             // Level (crude)
             const upVector = new CANNON.Vec3(0, 1, 0);
             const quat = this.websiteBody.quaternion; // Get world up
             const worldUp = new CANNON.Vec3(0, 1, 0);
             quat.vmult(upVector, worldUp); // Rotate up
             const correctionTorque = new CANNON.Vec3().cross(worldUp, new CANNON.Vec3(0, 1, 0)).scale(forceScale / 10); // Correct
             this.websiteBody.applyTorque(correctionTorque);


            if (this.websiteBody.velocity.length() > maxLinearVelocity) { // Speed limit
                 this.websiteBody.velocity.scale(maxLinearVelocity / this.websiteBody.velocity.length(), this.websiteBody.velocity); // Scale
             }
            if (this.websiteBody.angularVelocity.length() > maxAngularVelocity) { // Ang limit
                this.websiteBody.angularVelocity.scale(maxAngularVelocity / this.websiteBody.angularVelocity.length(), this.websiteBody.angularVelocity); // Scale
            }
        }
    }

    // Start the experience
    new Interactive3DWebsite();
</script>
</body>
</html>
